// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {BaseStrategy, StrategyParams} from "@badger/contracts/BaseStrategy.sol";
import {SafeERC20, SafeMath, IERC20, Address} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

// Import interfaces for many popular DeFi projects, or add your own!
import "../interfaces/uniswap/IUniswapRouterV2.sol";
import "../interfaces/uniswap/IStakingRewards.sol";



contract Strategy is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;
    

    address public constant reward = 0x831753DD7087CaC61aB5644b308642cc1c33Dc13; // Quick

    address public constant STAKING_REWARDS = 0x8f2ac4EC8982bF1699a6EeD696e204FA2ccD5D91;
    address public constant QUICKSWAP_ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;

    address public constant wbtc = 0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6;
    address public constant usdc = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;
    address public constant weth = 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619;

    // slippage tolerance 0.5% (divide by 1000) 
    uint256 public sl = 5;

    event Debug(string name, uint256 value);

    function initialize(
        address _vault,
        address _strategist,
        address _rewards,
        address _keeper
    ) external {
        BaseStrategy._initialize(_vault, _strategist, _rewards, _keeper);

        // Do more stuff here if you want
        // minReportDelay = 0;
        // maxReportDelay = 86400;
        // profitFactor = 100;
        // debtThreshold = 0;

        // Do one-off approvals here
        IERC20(want).safeApprove(STAKING_REWARDS, type(uint256).max);
        IERC20(wbtc).safeApprove(STAKING_REWARDS, type(uint256).max);
        IERC20(usdc).safeApprove(STAKING_REWARDS, type(uint256).max);

        IERC20(reward).safeApprove(QUICKSWAP_ROUTER, type(uint256).max);
        IERC20(weth).safeApprove(QUICKSWAP_ROUTER, type(uint256).max);
        IERC20(wbtc).safeApprove(QUICKSWAP_ROUTER, type(uint256).max);
        IERC20(usdc).safeApprove(QUICKSWAP_ROUTER, type(uint256).max);
    }

    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************

    function name() external view override returns (string memory) {
        // Add your own name here, suggestion e.g. "StrategyCreamYFI"
        return "QUICKSWAP WBTC-USDC Farming";
    }

    function balanceOfPool() public view returns (uint256) {
        return IStakingRewards(STAKING_REWARDS).balanceOf(address(this));
    }

    function balanceOfWant() public view returns (uint256) {
        return IERC20(want).balanceOf(address(this));
    }

    function estimatedTotalAssets() public view override returns (uint256) {
        // Sum of want + staked
        return balanceOfWant().add(balanceOfPool());
    }

    function checkPendingReward() public view returns (uint256) {
        return IStakingRewards(STAKING_REWARDS).earned(address(this));
    }


    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position
        // This would be the old harvest, where you just report _profit, _loss and _debtPayment

        uint256 _before = IERC20(want).balanceOf(address(this));

        uint256 _reward = checkPendingReward();

        if (_reward > 0) {
            IStakingRewards(STAKING_REWARDS).getReward();
            _quickToLP();
            _profit = IERC20(want).balanceOf(address(this)).sub(_before);
        }


        _debtPayment = _debtOutstanding;

        if(_debtPayment > 0){
            IStakingRewards(STAKING_REWARDS).withdraw(_debtPayment);
        }
        emit Debug("_debtOutstanding", _debtOutstanding);
        emit Debug("_profit", _profit);
        emit Debug("_loss", _loss);
        emit Debug("_debtPayment", _debtPayment);
        return (_profit, _loss, _debtPayment);
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // TODO: Do something to invest excess `want` tokens (from the Vault) into your positions
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)
        // This is tend, not much to change here
        uint256 balance = IERC20(want).balanceOf(address(this));
        if(balance > _debtOutstanding){
            IStakingRewards(STAKING_REWARDS).stake(balance.sub(_debtOutstanding));
        }

        if(_debtOutstanding > balance){
            // We need to withdraw
            IStakingRewards(STAKING_REWARDS).withdraw(_debtOutstanding.sub(balance));
        }
    }

    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        // TODO: Do stuff here to free up to `_amountNeeded` from all positions back into `want`
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`

        if(_amountNeeded > balanceOfWant()) {
            uint256 toWithdraw = _amountNeeded.sub(balanceOfWant());
            if(toWithdraw > balanceOfPool()){
                toWithdraw = balanceOfPool();
            }
            IStakingRewards(STAKING_REWARDS).withdraw(toWithdraw);
        }


        uint256 totalAssets = want.balanceOf(address(this));
        if (_amountNeeded > totalAssets) {
            _liquidatedAmount = totalAssets;
            _loss = _amountNeeded.sub(totalAssets);
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    function liquidateAllPositions() internal override returns (uint256) {
        // This is a generalization of withdrawAll that withdraws everything for the entire strat
        uint256 _totalWant = balanceOfPool();
        if (_totalWant > 0) {
            IStakingRewards(STAKING_REWARDS).withdraw(_totalWant);
        }

        // TODO: Liquidate all positions and return the amount freed.
        return want.balanceOf(address(this));
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function prepareMigration(address _newStrategy) internal override {
        // TODO: Transfer any non-`want` tokens to the new strategy
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        // This is gone if we use upgradeable
        prepareReturn(0); // Harvest cause why not
        liquidateAllPositions(); // In this case, we can just withdraw all and we'll be good
    }

    // Override this to add all tokens/tokenized positions this contract manages
    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)
    // NOTE: Do *not* include `want`, already included in `sweep` below
    //
    // Example:
    //
    //    function protectedTokens() internal override view returns (address[] memory) {
    //      address[] memory protected = new address[](3);
    //      protected[0] = tokenA;
    //      protected[1] = tokenB;
    //      protected[2] = tokenC;
    //      return protected;
    //    }
    function protectedTokens()
        public
        view
        override
        returns (address[] memory)
    {
        address[] memory protected = new address[](4);
        protected[0] = STAKING_REWARDS;
        protected[1] = reward;
        protected[2] = wbtc;
        protected[3] = usdc;
    }

    /**
     * @notice
     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)
     *  to `want` (using the native decimal characteristics of `want`).
     * @dev
     *  Care must be taken when working with decimals to assure that the conversion
     *  is compatible. As an example:
     *
     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),
     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)
     *
     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`
     * @return The amount in `want` of `_amtInEth` converted to `want`
     **/
    function ethToWant(uint256 _amtInWei)
        public
        view
        virtual
        override
        returns (uint256)
    {
        // TODO create an accurate price oracle
        return _amtInWei;
    }

    /// @dev QUICK TO WBTC-USDC LP 
    function _quickToLP() internal {
        uint256 _tokens = IERC20(reward).balanceOf(address(this));
        uint256 _half = _tokens.mul(500).div(1000);

        // quick to weth to wbtc
        address[] memory path = new address[](3);
        path[0] = reward;
        path[1] = weth;
        path[2] = wbtc;
        IUniswapRouterV2(QUICKSWAP_ROUTER).swapExactTokensForTokens(_half, 0, path, address(this), now);

        // quick to usdc
        path = new address[](2);
        path[0] = reward;
        path[1] = usdc;
        IUniswapRouterV2(QUICKSWAP_ROUTER).swapExactTokensForTokens(_tokens.sub(_half), 0, path, address(this), now);

        uint256 _wbtcIn = IERC20(wbtc).balanceOf(address(this));
        uint256 _usdcIn = IERC20(usdc).balanceOf(address(this));
        // add to WBTC-USDC LP pool for pool tokens
        IUniswapRouterV2(QUICKSWAP_ROUTER).addLiquidity(wbtc, usdc, _wbtcIn, _usdcIn, _wbtcIn.mul(sl).div(1000), _usdcIn.mul(sl).div(1000), address(this), now);
    }   
 
    function setSlippageTolerance(uint256 _s) external onlyAuthorized {
        sl = _s;
    }
}
